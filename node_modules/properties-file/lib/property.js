"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Property = void 0;
var unescape_1 = require("./unescape");
/**
 * Object representing a property (key/value).
 */
var Property = /** @class */ (function () {
    /**
     * Create a new property object.
     *
     * @param propertyLine - A property line object.
     * @param startingLineNumber - The line number at which the property starts.
     */
    function Property(propertyLine, startingLineNumber) {
        /** The property key, including its escaped characters. */
        this.escapedKey = '';
        /** The property value, including its escaped characters. */
        this.escapedValue = '';
        /** Was the property's key used more than once? */
        this.hasKeyCollisions = false;
        /** The property key (unescaped). */
        this.key = '';
        /** Starting line numbers of property objects with the same key. */
        this.keyCollisionLines = [];
        /** Positions of the newline characters if any. */
        this.newlinePositions = [];
        /** The property value (unescaped). */
        this.value = '';
        /** Does the key definition spread across multiple lines? */
        this.hasMultilineKey = false;
        /** Is the key empty? */
        this.hasNoKey = false;
        /** Is the value empty? */
        this.hasNoValue = false;
        this.linesContent = propertyLine.content;
        this.startingLineNumber = startingLineNumber;
    }
    /**
     * Add the a line to a multiline property object.
     *
     * @param propertyLine - A property line object.
     */
    Property.prototype.addLine = function (propertyLine) {
        if (this.linesContent.length > 0) {
            this.newlinePositions.push(this.linesContent.length);
        }
        this.linesContent += propertyLine.content;
    };
    /**
     * Set the property's key and value.
     */
    Property.prototype.setKeyAndValue = function () {
        this.findDelimiter();
        if (this.delimiterPosition !== undefined && this.delimiterLength !== undefined) {
            // Set key if present.
            if (!this.hasNoKey) {
                this.escapedKey = this.linesContent.slice(0, this.delimiterPosition);
                this.key = this.unescapeLine(this.escapedKey, this.startingLineNumber);
            }
            // Set value if present.
            if (!this.hasNoValue) {
                this.escapedValue = this.linesContent.slice(this.delimiterPosition + this.delimiterLength);
                this.value = this.unescapeLine(this.escapedValue, this.startingLineNumber);
            }
        }
        else if (this.hasNoValue) {
            // Set key if present (no delimiter).
            this.escapedKey = this.linesContent;
            this.key = this.unescapeLine(this.escapedKey, this.startingLineNumber);
        }
    };
    /**
     * Unescape the content from either key or value of a property.
     *
     * @param escapedContent - The content to unescape.
     * @param startingLineNumber - The starting line number of the content being unescaped.
     *
     * @returns The unescaped content.
     *
     * @throws {@link Error}
     * This exception is thrown if malformed escaped unicode characters are present.
     */
    Property.prototype.unescapeLine = function (escapedContent, startingLineNumber) {
        try {
            return (0, unescape_1.unescapeContent)(escapedContent);
        }
        catch (error) {
            throw new Error("".concat(error.message, " in property starting at line ").concat(startingLineNumber));
        }
    };
    /**
     * Find the delimiting characters separating the key from the value.
     */
    Property.prototype.findDelimiter = function () {
        var _a, _b;
        // If the delimiter was already found, skip.
        if (this.hasNoKey || this.hasNoValue || this.delimiterPosition) {
            return;
        }
        for (var character = this.linesContent[0], position = 0; position < this.linesContent.length; position++, character = this.linesContent[position]) {
            // If the character is not a delimiter, check the next one.
            if (!/[\t\f :=]/.test(character)) {
                continue;
            }
            // Check if the delimiter might be escaped.
            var prefix = position ? this.linesContent.slice(0, position) : '';
            if (prefix.length > 0) {
                var backslashMatch = prefix.match(/(?<backslashes>\\+)$/);
                if (backslashMatch === null || backslashMatch === void 0 ? void 0 : backslashMatch.groups) {
                    var delimiterIsEscaped = !!(backslashMatch.groups.backslashes.length % 2);
                    if (delimiterIsEscaped) {
                        // If the delimiter is escaped, check the next character.
                        continue;
                    }
                }
            }
            var delimiter = '';
            this.delimiterPosition = position;
            this.hasMultilineKey = !!(this.newlinePositions.length > 0 && this.newlinePositions[0] > position);
            // Check if the delimiter starts with a whitespace.
            var nextContent = this.linesContent.slice(position);
            var leadingWhitespaceMatch = nextContent.match(/^(?<whitespace>\s+)/);
            var leadingWhitespace = ((_a = leadingWhitespaceMatch === null || leadingWhitespaceMatch === void 0 ? void 0 : leadingWhitespaceMatch.groups) === null || _a === void 0 ? void 0 : _a.whitespace) || '';
            // If there is a whitespace, move to the next character.
            if (leadingWhitespace.length > 0) {
                delimiter += leadingWhitespace;
                nextContent = nextContent.slice(leadingWhitespace.length);
            }
            // Check if there is an equal or colon character.
            if (/[:=]/.test(nextContent[0])) {
                delimiter += nextContent[0];
                nextContent = nextContent.slice(1);
                // If an equal or colon character was found, try to get trailing whitespace.
                var trailingWhitespaceMatch = nextContent.match(/^(?<whitespace>\s+)/);
                var trailingWhitespace = ((_b = trailingWhitespaceMatch === null || trailingWhitespaceMatch === void 0 ? void 0 : trailingWhitespaceMatch.groups) === null || _b === void 0 ? void 0 : _b.whitespace) || '';
                delimiter += trailingWhitespace;
            }
            this.delimiterLength = delimiter.length;
            // If the line starts with a delimiter, the property has no key.
            if (!position) {
                this.hasNoKey = true;
            }
            break;
        }
        // If there was no delimiter found, the property has no value.
        if (this.delimiterPosition === undefined) {
            this.hasNoValue = true;
        }
        else {
            // If the delimiter is after the first newline, mark the key as multiline.
            if (this.newlinePositions.length > 0) {
                var firstLinePosition = this.newlinePositions[0];
                if (firstLinePosition > this.delimiterPosition) {
                    this.hasMultilineKey = true;
                }
            }
        }
    };
    return Property;
}());
exports.Property = Property;
