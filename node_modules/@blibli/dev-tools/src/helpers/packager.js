const fs = require('fs')
const fse = require('fs-extra')
const path = require('path')
const chalk = require('chalk')
const archiver = require('archiver')
const pathUtil = require('../utils/path')
const {packager: packagerConfig} = require('./blibli-dev-tools.config')
const { sanitizeFileName } = require('../utils/file')

const GROUP_ID = packagerConfig.groupId

const projectDir = pathUtil.root.path
const target = 'target'
const dist = packagerConfig.distDir
const healthcheckLabel = 'healthcheck'
const versionLabel = 'version'
const targetDir = path.join(projectDir, target)
const defaultFiles = [healthcheckLabel, versionLabel]
const cleanUps = packagerConfig.cleanUps.concat(defaultFiles)
const includes = packagerConfig.includes.files.concat(packagerConfig.includes.dirs)
const adaptiveTargets = packagerConfig.adaptiveTargets
const ADAPTIVE_TYPES = ['desktop', 'mobile']

let mode = ''
let targetFileName = ''
let targetResourcesFileName = ''
let archFolder = ''
let archResourcesFolder = ''
let output
let outputResource

const {
  npm_package_name,
  npm_package_version: packageVersion
} = process.env

const packageName = sanitizeFileName(npm_package_name)

async function doPackage(inputMode){
  console.log('Checking package name..')
  const isPackageNameSanitized = packageName !== npm_package_name
  if (isPackageNameSanitized) {
    console.log(chalk.yellow(`Your package name is sanitized from "${npm_package_name}" to "${packageName}"`))
  } else {
    console.log(chalk.green('Package name OK.'))
  }

  console.log('preparing archive..')
  prePackage(inputMode)

  console.log('archiving folder..')
  if(!packagerConfig.isCollab){
    // archive main zip
    await archive(output, outputArchiveAction, outputCloseHandler)
  }
  else{
    // replicate files to desktop and mobile folder
    adaptiveTargets.forEach(async item => {
      if(item.source == item.target){
        await duplicateFilesForDevice(item.source)
      }
    })
  }
  // create resource archive
  archive(outputResource, outputResourceArchiveAction, outputResourceCloseHandler)
}

function prePackage(inputMode){
  mode = inputMode === 'RELEASE' ? '' : ('-' + inputMode)

  targetFileName = packageName + '-' + packageVersion + mode + '.zip'
  targetResourcesFileName = packageName + '-resources-' + packageVersion + mode + '.zip'

  archFolder = path.join(GROUP_ID + '-' + packageName, packageVersion + mode)
  archResourcesFolder = path.join(GROUP_ID + '-' + packageName + '-resources', packageVersion + mode)

  // Ensure target directory exist
  fse.ensureDirSync(targetDir)

  // Move dist to target folder
  adaptiveTargets.forEach(item => {
    const distPath = path.join(projectDir, item.source, dist)
    try {
      fs.statSync(distPath)
      console.log('copying', item.source, dist, 'to', item.target, 'target')
      fse.copySync(path.join(projectDir, item.source, dist), path.join(targetDir, item.target))
    } catch (error) {
      console.log(chalk.bold.red("Error: No directory '" + dist + "'. Please build the project before archiving..."))
      process.exit()
    }
  })

  // create a file to stream archive data to.
  if(!packagerConfig.isCollab){
    output = fs.createWriteStream(path.join(targetDir,targetFileName))
  }
  outputResource = fs.createWriteStream(path.join(targetDir,targetResourcesFileName))

  // create additional files
  createAdditionalFiles(packageVersion + mode, packageName)
}

function outputArchiveAction(archive){
  const files = packagerConfig.includes.files
  const folders = packagerConfig.includes.dirs

  //Adaptive Target
  adaptiveTargets.forEach(item => {
    for (let i in files) {
      const filePath = path.join(projectDir, target, item.source, files[i])
      try {
        fs.statSync(filePath)
        archive.file(filePath, {
          name: files[i],
          prefix: path.join(archFolder, item.target)
        })
      } catch (error) {
        console.log(chalk.bold.yellow("Warning: No files " + "'" + files[i] + "'"))
      }
    }
    for (let i in folders) {
      const directoryPath = path.join(projectDir, target, item.source, folders[i]) 
      try {
        fs.statSync(directoryPath)
        archive.directory(directoryPath,path.join( archFolder, item.target, folders[i]))
      } catch (error) {
        console.log(chalk.bold.yellow('Warning: No directory ' + "'" + folders[i] + "'"))
      }
    }
  })
  archive.file(path.join(projectDir, target, versionLabel), {
    name: versionLabel,
    prefix: path.join( archFolder )
  })
  archive.file(path.join(projectDir, target, healthcheckLabel), {
    name: healthcheckLabel,
    prefix: path.join( archFolder )
  })
}

function outputCloseHandler(archive){
  const fileSize = (archive.pointer() / 1024)
  const fileSizeRound = Math.round(fileSize * 100) / 100
  console.log('Output file: ' + targetFileName + ' => ' + fileSizeRound + 'KBs')

  //create maven file
  createMaven(packageVersion + mode, targetFileName, packageName)
}

function outputResourceArchiveAction(archive){
  adaptiveTargets.forEach(item => {
    if(item.source == item.target){
      const directoryPath = path.join(projectDir, target, item.source, '/', 'static')
      try {
        fs.statSync(directoryPath)
        archive.directory(directoryPath,
          path.join( archResourcesFolder, item.target, '/', 'static'))
      } catch (error) {
        console.log(chalk.bold.yellow('Warning: No directory ' + "'static'" + ' for resources'))
      }
    }
  })
  if(packagerConfig.isCollab){
    archive.file(path.join(projectDir, target, versionLabel), {
      name: versionLabel,
      prefix: path.join(archResourcesFolder)
    })
    archive.file(path.join(projectDir, target, healthcheckLabel), {
      name: healthcheckLabel,
      prefix: path.join(archResourcesFolder)
    })
  }
}

function outputResourceCloseHandler(archive){
  const fileSize = (archive.pointer() / 1024)
  const fileSizeRound = Math.round(fileSize * 100) / 100
  console.log('Output file: ' + targetResourcesFileName + ' => ' + fileSizeRound + 'KBs')

  // clean up
  const cleanUpItems =  [...new Set([...cleanUps, ...includes])]
  cleanUpItems.forEach(item => {
    fse.removeSync(path.join(targetDir, item))
  });

  // create maven file
  createMaven(packageVersion + mode, 
    targetResourcesFileName, packageName + '-resources', 'pom-resources.xml')
}

function archive(output, archiveAction, closeHandler){
  return new Promise((resolve, reject) => {
    const archive = archiver('zip', {
      zlib: {level: 9} // Sets the compression level.
    })
  
    // listen for all archive data to be written
    output.on('close', () => {
      closeHandler(archive),
      resolve(archive)
    })
  
    // good practice to catch this error explicitly
    archive.on('error', (err) => reject(err))
  
    // pipe archive data to the file
    archive.pipe(output)
  
    archiveAction(archive)
  
    archive.finalize()
  })
}

// create maven package file
function createMaven(version, targetFileName, packageName, pomFile = 'pom.xml'){
  const output = '<?xml version="1.0" encoding="UTF-8"?>\n' +
    '<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">\n' +
    '  <modelVersion>4.0.0</modelVersion>\n' +
    '  <groupId>' + GROUP_ID + '</groupId>\n' +
    '  <artifactId>' + packageName + '</artifactId>\n' +
    '  <packaging>pom</packaging>\n' +
    '  <version>' + version + '</version>\n' +
    '  <name>' + packageName + '</name>\n' +
    '  <properties>\n' +
    '    <file>target/'+targetFileName+'</file>\n' +
    '  </properties>\n' +
    '</project>\n'

  // write file
  fs.writeFileSync(pomFile, output)
}

function createAdditionalFiles(version, packageName){
  // health
  const healthString = '{"status":"UP"}'

  // version
  const versionString =
    'maven.groupId=' + GROUP_ID + '\n' +
    'maven.artifactId=' + packageName + '\n' +
    'maven.pom.version=' + version + '\n' +
    'maven.build.time=' + new Date().toISOString().replace('T',' ').substr(0,19)

  fs.writeFileSync(path.join(projectDir, target, healthcheckLabel), healthString)
  fs.writeFileSync(path.join(projectDir, target, versionLabel), versionString)
}

async function duplicateFilesForDevice(staticDir){
  const staticFolder = path.join(projectDir, staticDir, 'dist', 'static')
  const targetFolder = path.join(targetDir, staticDir, 'static')

  const version = process.env.npm_package_version
  const versionFolder = path.join(targetFolder, version)

  const temporaryFolder = path.join(targetFolder, 'temp')
  const desktopFolder = path.join(versionFolder, 'desktop')
  const mobileFolder = path.join(versionFolder, 'mobile')
  const adaptiveFolder = path.join(versionFolder, staticDir)

  const hasVersionFolder = fs.existsSync(versionFolder)

  console.log('preparing '+ staticDir +' folder')
  // backward compatibility for webpack build
  const sourceFolder = hasVersionFolder ? versionFolder : staticFolder
  fse.copySync(sourceFolder, temporaryFolder)
  if(ADAPTIVE_TYPES.includes(staticDir)) {
    console.log(chalk.green('Copying ' + sourceFolder + ' to ' + adaptiveFolder))
    fse.copySync(temporaryFolder, adaptiveFolder)
  }
  else{
    console.log(chalk.green('Copying ' + sourceFolder + ' to ' + desktopFolder))
    console.log(chalk.green('Copying ' + sourceFolder + ' to ' + mobileFolder))
    fse.copySync(temporaryFolder, desktopFolder)
    fse.copySync(temporaryFolder, mobileFolder)
  }
  fse.removeSync(temporaryFolder)
}

module.exports = {
  doPackage
}