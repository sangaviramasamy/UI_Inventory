
#if canImport(SwiftUI)
import Foundation
import SwiftUI

func getGlobalTokenDictionary() throws -> [GlobalTokenType : TokenDict]  {
    var globalTokenDictionary: [GlobalTokenType: TokenDict] = [:]
    let dictionary = try loadToken(filePath: globalJsonPath, tokenType: .global)
    
    for dictElement in dictionary {
        let dictionaryValue: [String : Any] = asDictionary(from: dictElement.value)
        let dictKey = dictElement.key.camelCased(with: "-")
        
        let childDict = try traverseGlobalDictionaryRaw(
            dictionary: dictionaryValue,
            with: dictKey
        )
        
        let tokenType = childDict.1
        let tokenDict = childDict.0
        if let existing = globalTokenDictionary[tokenType] {
            var copy = existing
            copy[dictKey] = tokenDict[dictKey]
            globalTokenDictionary[tokenType] = copy
        } else {
            globalTokenDictionary[tokenType] = tokenDict
        }
    }
    return globalTokenDictionary
}

func getAliasTokenDictionary(path: String, tokenType: TokenType) throws -> [AliasTokenType : TokenDict]  {
    var globalTokenDictionary: [AliasTokenType: TokenDict] = [:]
    let dictionary = try loadToken(filePath: path, tokenType: tokenType)
    
    for dictElement in dictionary {
        let dictionaryValue: [String : Any] = asDictionary(from: dictElement.value)
        let dictKey = dictElement.key.camelCased(with: "-")
        
        let childDict = try traverseAliasDictionary(
            dictionary: dictionaryValue,
            with: dictKey
        )
        
        let aliasTokenType = childDict.1
        let aliasTokenDict = childDict.0
        if let existing = globalTokenDictionary[aliasTokenType] {
            var copy = existing
            copy[dictKey] = aliasTokenDict[dictKey]
            globalTokenDictionary[aliasTokenType] = copy
        } else {
            globalTokenDictionary[aliasTokenType] = aliasTokenDict
        }
    }
    return globalTokenDictionary
}


func traverseAliasDictionary(dictionary: [String : Any], with parentKey: String) throws -> (TokenDict, AliasTokenType)  {
    if dictionary.keys.contains("type") {
        let type: String = String(describing: dictionary["type"] ?? "")
        let tokenType: AliasTokenType = .init(value: type)
        
        switch tokenType {
        case .color:
            var color: ColorModel = .init()
            var colorAlias: String = String(describing: dictionary["value"] ?? "")
        
            if (colorAlias.first == "{" && colorAlias.last == "}") == false {
                let closingBraceIndex = colorAlias.firstIndex(of: "}") ?? colorAlias.endIndex
                let alphaHex: String = String(colorAlias.split(separator: "}").last ?? "ff")
                color.opacityHex = alphaHex
                colorAlias = String(colorAlias[colorAlias.startIndex...closingBraceIndex])
            }
            color.colorAlias = colorAlias.camelCased(with: ".")
            let dict = [parentKey: color]
            return (dict, tokenType)
            
        case .fontFamilies:
            let value: String = String(describing: dictionary["value"] ?? "")
            let typeface: String = String(describing: value.split(separator: ".").first ?? "")
            let fontName: String = String(describing: value.split(separator: ".").last ?? "")
            let variableValue = typeface + fontName.camelCased(with: "-").capitalizingFirstLetter()
            return ([parentKey: variableValue], tokenType)
            
        case .typography:
            let typographyDictionary = asDictionary(from: dictionary["value"])
            // tokens
            let fontFamily: String = typographyDictionary["fontFamily"].asString()
            let fontSize: String = typographyDictionary["fontSize"].asString()
            let fontWeightKey: String = typographyDictionary["fontWeight"].asString()
            let lineHeight: String = typographyDictionary["lineHeight"].asString()
            // values
            let letterSpacing: String = typographyDictionary["letterSpacing"].asString()
            let paragraphSpacing: String = typographyDictionary["paragraphSpacing"].asString()
            let textDecoration: String = typographyDictionary["textDecoration"].asString()
            let textCase: String = typographyDictionary["textCase"].asString()
            
            let fontAlias: String = String(fontFamily.split(separator: ".").last?.split(separator: "}").first ?? .init()).camelCased(with: "-")
            let sizeToken: String? = String(fontSize.camelCased(with: "-").camelCased(with: ".", lowercase: false))
            let weightToken: String? = String(fontWeightKey.camelCased(with: "-").camelCased(with: ".", lowercase: false))
            let lineHeightAlias: String? = String(lineHeight.camelCased(with: "-").camelCased(with: ".", lowercase: false))
            

            let typographyModel = TypographyModel(
                globalFontWeight: weightToken,
                globalFontSize: sizeToken,
                fontFamilyAlias: fontAlias,
                lineHeightAlias: lineHeightAlias,
                letterSpacing: letterSpacing,
                paragraphSpacing: paragraphSpacing,
                textCase: textCase,
                textDecoration: textDecoration
            )
            
            return ([parentKey: typographyModel], tokenType)
            
        case .boxShadow:
            // Reminder that in the meantime we pass the string as-is
            // to the generator
            let shadowDict = asDictionary(from: dictionary["value"])
            let shadowModel = ShadowModel(
                x: shadowDict["x"].asString(),
                y: shadowDict["y"].asString(),
                blur: shadowDict["blur"].asString(),
                spread: shadowDict["spread"].asString(),
                color: shadowDict["color"].asString(),
                type: shadowDict["type"].asString()
            )
            return ([parentKey: shadowModel], tokenType)
            
        case .spacing, .sizing, .opacity, .borderRadius:
            let value: String = String(describing: dictionary["value"] ?? "")
            if value.first == "{" && value.last == "}" {
                let alias = value.camelCased(with: ".")
                return ([parentKey: alias], tokenType)
            }
            
            return ([parentKey: value], tokenType)
            
        case .any:
            return ([:], .any)
        }
    } else {
        var aliasDict: TokenDict = [:]
        var tokenType: AliasTokenType = .any
        for dict in dictionary {
            let childDictionary = asDictionary(from: dict.value)
            let childDictKey: String = dict.key.camelCased(with: "-")

            let staticVariablesContent = try traverseAliasDictionary(dictionary: childDictionary, with: childDictKey)
            let childTokenType = staticVariablesContent.1
            if tokenType != .any && childTokenType != tokenType {
                throw ErrorType.general("Design token type inconsistent")
            }
            tokenType = childTokenType
            let tokenDict = staticVariablesContent.0

            if let existing = aliasDict[parentKey] as? TokenDict {
                var copy = existing
                copy[childDictKey] = tokenDict[childDictKey]
                aliasDict[parentKey] = copy
            } else {
                aliasDict[parentKey] = tokenDict
            }
        }

        return (aliasDict, tokenType)
    }
}
    

func traverseGlobalDictionaryRaw(
    dictionary: TokenDict,
    with parentKey: String
) throws -> GlobalTokenNode {
    if dictionary.keys.contains("type") {
        let type: String = String(describing: dictionary["type"] ?? "")
        let value: String = String(describing: dictionary["value"] ?? "")
        let tokenType: GlobalTokenType = .init(value: type)
        let dict = [parentKey: value]
        return (dict, tokenType)
    } else {
        var globalDict: TokenDict = [:]
        var tokenType: GlobalTokenType = .any
        for dict in dictionary {
            let childDictionary = asDictionary(from: dict.value)
            /// e.g. parentKey is Red, dict.key is 10 becomes red10
            /// or parentKey is font-size, dict.key is 10 becomes fontSize10
            let childDictKey: String = parentKey.appending(
                dict.key.camelCased(with: "-").capitalizingFirstLetter()
            )
            let childValue = try traverseGlobalDictionaryRaw(
                dictionary: childDictionary,
                with: childDictKey
            )
            
            let childtokenType = childValue.1
            if tokenType != .any && childtokenType != tokenType {
                throw ErrorType.general("Design token type inconsistent")
            }
            tokenType = childtokenType
            let dictionary = childValue.0
            guard dictionary.count == 1 else {
                throw ErrorType.general("Incompatible json format")
            }
            if let existing = globalDict[parentKey] as? TokenDict {
                var copy = existing
                copy[childDictKey] = dictionary[childDictKey]
                globalDict[parentKey] = copy
            } else {
                globalDict[parentKey] = dictionary
            }
        }
        return (globalDict, tokenType)
    }
}

// MARK: Shared Global Functions

func removeBorderBraces(from string: String) -> String {
    var copy = string
    if string.first == "{" {
        copy.removeFirst()
    }
    if string.last == "}" {
        copy.removeLast()
    }
    return copy
}

func loadToken(filePath: String, tokenType: TokenType) throws -> TokenDict {
    guard FileManager.default.fileExists(atPath: filePath) else {
        throw ErrorType.fileUrlNotFound(tokenType: tokenType)
    }
    
    guard let data = FileManager.default.contents(atPath: filePath) else {
        throw ErrorType.invalidData(tokenType: tokenType)
    }
    
    guard let object = try? JSONSerialization.jsonObject(with: data, options: .fragmentsAllowed),
          let dictionary = object as? [String : Any] else {
        throw ErrorType.serializationFailed(tokenType: tokenType)
    }
    
    return dictionary
}

func removePathAt(_ path: String, isDirectory: Bool = false){
    var _isDirectory: ObjCBool = ObjCBool(isDirectory)
    if FileManager.default.fileExists(atPath: path , isDirectory: &(_isDirectory)) {
        try? FileManager.default.removeItem(atPath: path)
    }
}

func isDirectoryExist(_ path: String) -> Bool {
    let _bool = true
    var _isDirectory: ObjCBool = ObjCBool(_bool)
    return FileManager.default.fileExists(atPath: path , isDirectory: &(_isDirectory))
}

func jsonStringFrom(encodable: some Encodable) throws -> String? {
    let encoder = JSONEncoder()
    encoder.outputFormatting = [
        .prettyPrinted,
        .sortedKeys
    ]
    let jsonData = try encoder.encode(encodable)
    let jsonString = String(data: jsonData, encoding: .utf8)
    return jsonString
}

func asDictionary(from any: Any?) -> TokenDict {
    any as? TokenDict ?? [:]
}

/// asString() for non optional Any, since Optional<Any> is  NOT non-nominal
func asString(from any: Any) -> String {
    any as? String ?? ""
}

func getRGBAfromHexString(_ hex: String) -> RGBA? {
    var hexValueString = hex
    if hexValueString.hasPrefix("#") {
        hexValueString = String(hexValueString.dropFirst())
    } else if hexValueString.hasPrefix("0x") {
        hexValueString = String(hexValueString.dropFirst(2))
    }
    // pad to set alpha to 1
    let sanitizedHexString = hexValueString.padding(
        toLength: 8, withPad: "ff", startingAt: 0
    )
    let isStringEvenLength = (sanitizedHexString.count & 1) == 0
    guard isStringEvenLength, let hexValue = Int(sanitizedHexString, radix: 16) else {
        return nil
    }
    
    let hexMask = 255 // 0xFF
    
    let a = Double(hexValue & hexMask)
    let r = Double((hexValue >> 24) & hexMask)
    let g = Double((hexValue >> 16) & hexMask)
    let b = Double((hexValue >> 8) & hexMask)
    
    return .init(r: r, g: g, b: b, a: a)
}

// Retrieves the available font files from blue-font.
///
/// - Parameters:
///   - path: The directory path where the font files are located.
///
/// - Throws:
///   - ErrorType.general: Thrown when the specified font directory does not exist.
///
/// - Returns: A set containing the available font weights found in the specified directory.
///
/// - Important:
///     This function only considers TrueType Font (TTF) files in the directory.
///     make sure the format in tokens/global.json is sync with this parsing function
///
func getAvailableFontFiles(path: String) throws -> Set<String> {
    guard isDirectoryExist(path) else { throw ErrorType.general("Invalid Font Directory: \(path)")}
    var result: Set<String> = .init()
    var fileNames = try FileManager.default.contentsOfDirectory(atPath: path)
    // only look at ttf files
    fileNames = fileNames.filter({$0.hasSuffix(".ttf")})
    result.formUnion(fileNames)
    return result
}

let fileManager = FileManager.default
let rootPath = fileManager.currentDirectoryPath
let rootDirname = rootPath.split(separator: "/").last ?? ""
if rootDirname != "blue-design-tokens" {
    print("CURRENT DIRECTORY: \(rootDirname)")
    print( "Not in project directory. In the meantime please execute this on the project root directory")
    throw "Incorrect directory"
}
let tokenPath = rootPath + "/tokens"
let iosPath = rootPath + "/dist/iOS"
let blueFontPath = rootPath + "/blue-font"
let globalJsonPath = tokenPath + "/" + TokenType.global.fileName
let aliasDarkJsonPath = tokenPath + "/" + TokenType.aliasDark.fileName
let aliasDefaultJsonPath = tokenPath + "/" + TokenType.aliasDefault.fileName
let libraryPath = iosPath + "/BLUE-SwiftUI"
let libraryResourcePath = libraryPath + "/Resources"
let blueFontDirPath = blueFontPath + "/src/sources"
// MARK: Always run GlobalTokenGeneator first. Some logic in alias token generation depends on global tokens discovery.
if #available(iOS 13.0, macOS 10.15, *){
    try GlobalTokenGenerator.generateColorAsset(resourcePath: libraryResourcePath, libraryPath: libraryPath, tokenType: .global)
}
// Create parent namespace for all alias tokens
let aliasTokenTypes = TokenType.allCases.filter({$0 != .global})
let availibilityCheck = "@available(iOS 13.0, macOS 10.15, *)"
let rootNameAliasNamespace = "BluAliasToken"
var aliasTokenTemplate = """
/// Generated File
// MARK: Blue 3.0 Alias token root namespaces
\(availibilityCheck)
public struct \(rootNameAliasNamespace) {\n
"""
for tokenType in aliasTokenTypes {
    aliasTokenTemplate += "\t public struct \(tokenType.tokenNameSpace) {}\n"
    try AliasTokenGenerator.generateAliasesForToken(tokenType: tokenType, libraryPath: libraryPath)
}
aliasTokenTemplate += "}\n"
try aliasTokenTemplate.write(toFile: libraryPath + "/\(rootNameAliasNamespace).swift", atomically: true, encoding: .utf8)
#endif

