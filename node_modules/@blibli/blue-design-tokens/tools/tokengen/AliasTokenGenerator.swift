//import Foundation
///// Adapted from BlueDLSTokenPackage
class AliasTokenGenerator {
    static let tokenPrefix = "blu"
    static func generateAliasesForToken(tokenType: TokenType, libraryPath: String) throws {
        let path = tokenPath+"/"+tokenType.fileName
        let dict = try? getAliasTokenDictionary(path: path, tokenType: tokenType)
            .sortByAlphaNumeric()
        
        guard let dict, tokenType != .global else { return }
        let parentScopeType = "\(rootNameAliasNamespace).\(tokenType.tokenNameSpace)"
        let fileName = tokenType.tokenNameSpace + ".swift"
        let outputDir = "BlueAliasTokens"
        let outputPath = libraryPath+"/"+outputDir+"/"+fileName
        let availibilityCheck = "@available(iOS 14.0, macOS 11, *)" // TODO: Make configurable
        let template = """
            /// Generated File
            #if canImport(SwiftUI)
            import SwiftUI
            // MARK: Blue 3.0 Alias tokens
            \(availibilityCheck)
            public extension \(parentScopeType) {\n\tstruct Blu {\n
            """
        var result = template
        let startingIndentation = 2
        var fontFamilySet: Set<String> = .init()
        var fontAliasToFontNameDict: [String: String] = [:]
        for token in dict {
            switch token.key {
            case .color:
                let colorNameSpace = getNameSpace(key: token.key.typeName)
                addTab(&result, n: startingIndentation)
                result += colorNameSpace
                addNewline(&result)
                let flatDict = try flattenColor(dictionaryInput: token.value, startingIndentation: startingIndentation + 1)
                result += flatDict
                addNewline(&result)
                addTab(&result, n: startingIndentation)
                result += "}"
                addNewline(&result)
                break

            case .fontFamilies:
                let nameSpace = getNameSpace(key: token.key.typeName)
                addTab(&result, n: startingIndentation)
                result += nameSpace
                addNewline(&result)
                let dict = asDictionary(from: token.value["fontFamily"]).sortByAlphaNumeric()
                for item in dict {
                    let aliasValue = try getValueFrom(valueString: item.value, tokenType: token.key)
                    fontAliasToFontNameDict[item.key] = GlobalTokenGenerator.availableTypefacesDictionary[aliasValue]
                    let variableName = getVariableName(item.key, tokenType: .fontFamilies)
                    let prop = getProperty(key: variableName, value: "."+aliasValue, dataType: token.key.propertyTypeName)
                    fontFamilySet.insert(item.key)
                    addTab(&result, n: startingIndentation + 1)
                    result += prop
                    addNewline(&result)
                }
                addTab(&result, n: startingIndentation)
                result += "}"
                addNewline(&result)
                break
                
            case .typography:
                func getFontFileName(typography: String, fontWeightToken: String) throws -> String {
                    guard let typeface = fontAliasToFontNameDict[typography],
                          let fontWeight = GlobalTokenGenerator.availableFontWeightDictionary[fontWeightToken]
                    else {
                        throw ErrorType.general("Invalid Font: \(typography) \(fontWeightToken)")
                    }
                    let fontToken = GlobalTokenGenerator.availableFontTokens.first(where: { fontToken in
                        return fontToken.tokenName == fontWeightToken &&
                        fontToken.typeface == typeface &&
                        fontToken.style == fontWeight
                    })
                    guard let fontToken, let name = fontToken.postScriptName else {
                        if let fontToken, fontToken.postScriptName == nil {
                            throw ErrorType.general("Font token has no postScriptName: \(typeface) \(fontWeight)")
                        } else {
                            throw ErrorType.general("Font Style not found: \(typeface) \(fontWeight)")
                        }
                    }

                    return name
                }
                
                func getProperty(variableName: String, model: TypographyModel) throws -> String {
                    let fontWeight = model.globalFontWeight
                    let typographyItem = model.fontFamilyAlias
                    let lineHeight: String? = model.lineHeightAlias
                    guard let typographyItem, let fontWeight, 
                        let lineHeight, fontFamilySet.contains(typographyItem)
                    else {
                        throw ErrorType.general("Invalid Font from Alias Token: \(model)")
                    }
                    let dataType = token.key.dataType
                    let fontWeightName = try getValueFrom(valueString: fontWeight, aliasTokenType: token.key)
                    let lineHeightName = try getValueFrom(valueString: lineHeight, aliasTokenType: token.key)
                    let fontSize = try getValueFrom(valueString: model.globalFontSize ?? "", aliasTokenType: token.key)
                    let typefaceValue = fontAliasToFontNameDict[typographyItem] ?? ""
                    let typeface = GlobalTokenGenerator.availableTypefacesDictionary.first(where: {$0.value == typefaceValue})?.key
                    guard let typeface else { throw "Invalid Typeface when creating typography" }
                    let weight = GlobalTokenGenerator.availableFontWeightDictionary[fontWeightName] ?? ""
                    let loadableFontName = try getFontFileName(
                        typography: typographyItem,
                        fontWeightToken: fontWeightName
                    )
                    
                    let indentLevel = startingIndentation + 2
                    let isFixedSize = true
                    let sizeParam = isFixedSize ? "fixedSize" : "size"
                    let customFontLine = """
                    \(getTab(n: indentLevel))font: .custom(\"\(loadableFontName)\", \(sizeParam): .\(fontSize))
                    """

                    let initializer = """
                    .init(
                    \(getTab(n: indentLevel))typeface: .\(typeface),
                    \(getTab(n: indentLevel))weight: .\(fontWeightName),
                    \(getTab(n: indentLevel))size: .\(fontSize),
                    \(getTab(n: indentLevel))lineHeight: .\(lineHeightName),
                    \(customFontLine)
                    \(getTab(n: indentLevel-1)))
                    """
                    return """
                    public static let \(variableName): \(dataType) = \(initializer)
                    """
                }
                let sortedDict = asDictionary(from: token.value).sortByAlphaNumeric()
                let nameSpace = getNameSpace(key: token.key.typeName)
                addTab(&result, n: startingIndentation)
                result += nameSpace
                addNewline(&result)
                for item in sortedDict {
                    guard let typography = item.value as? TypographyModel else { throw ErrorType.general("Wrong model") }
                    let fontWeightName = try getValueFrom(valueString: typography.globalFontWeight ?? "", aliasTokenType: .typography)
                    guard let _ = GlobalTokenGenerator.availableFontWeightDictionary[fontWeightName] else {
                        throw ErrorType.general("Font weight \(fontWeightName) is not in Global Token definition")
                    }
                    
                    let property = try getProperty(variableName: item.key, model: typography)
                    addTab(&result, n: startingIndentation + 1)
                    result += property
                    addNewline(&result)
                }
                addTab(&result, n: startingIndentation)
                result += "}"
                addNewline(&result)

            case .spacing, .opacity, .sizing, .borderRadius:
                let dictKey = token.key.jsonKey.camelCased(with: "-")
                let dict = asDictionary(from:token.value[dictKey]).sortByAlphaNumeric(by: .value) { value in
                    return (value as? String)
                }

                // MARK: generate docstring (REFACTOR LATER PLS)
                var docString = "/** "
                addNewline(&docString)
                addTab(&docString, n: startingIndentation)
                docString += "This namespace contains the following members, with their alias and value:\n"
                for (index, item) in dict.enumerated() {
                    guard isAliasIgnored(type: token.key, key: item.key) == false else { continue }
                    let aliasValue = try getValueFrom(valueString: item.value, tokenType: token.key)
                    let variableName = getVariableName(item.key, tokenType: token.key)

                    addTab(&docString, n: startingIndentation)
                    docString += "\(variableName) -> \(aliasValue): \(GlobalTokenGenerator.availableGlobalTokensDict[aliasValue] ?? "nil")"
                    if index != dict.endIndex {
                        addNewline(&docString)
                    }
                }

                let nameSpace = getNameSpace(key: token.key.typeName)
                addTab(&result, n: startingIndentation)
                result += docString 
                addTab(&result, n: startingIndentation)
                result += "*/"
                addNewline(&result)
                addTab(&result, n: startingIndentation)
                result += nameSpace
                addNewline(&result)
                
                for item in dict {
                    guard isAliasIgnored(type: token.key, key: item.key) == false else { continue }
                    let aliasValue = try getValueFrom(valueString: item.value, tokenType: token.key)
                    let variableName = getVariableName(item.key, tokenType: token.key)
                    let prop = getProperty(
                        key: variableName,
                        value: "."+aliasValue,
                        dataType: token.key.propertyTypeName
                    )

                    addTab(&result, n: startingIndentation + 1)
                    result += "/// \(aliasValue): \(GlobalTokenGenerator.availableGlobalTokensDict[aliasValue] ?? "nil")"
                    addNewline(&result)

                    addTab(&result, n: startingIndentation + 1)
                    result += prop
                    addNewline(&result)
                }
                addTab(&result, n: startingIndentation)
                result += "}"
                addNewline(&result)
                break
            case .boxShadow:                
                let nameSpace = getNameSpace(key: token.key.typeName)
                let dictKey = token.key.jsonKey
                addTab(&result, n: startingIndentation)
                result += nameSpace
                addNewline(&result)
                func getBluShadowModel(_ model: ShadowModel) -> String {
                    let colorValue = try! getValueFrom(
                    valueString: model.color!,
                    aliasTokenType: .boxShadow,
                    globalTokenType: .color,
                    prefixedWithDot: true
                   )
                    let xPos = try! getValueFrom(
                        valueString: model.x!,
                        aliasTokenType: .boxShadow,
                        globalTokenType: .sizing,
                        prefixedWithDot: true
                    )
                    let yPos = try! getValueFrom(
                        valueString: model.y!,
                        aliasTokenType: .boxShadow,
                        globalTokenType: .sizing,
                        prefixedWithDot: true
                    )
                    let blur = try! getValueFrom(
                        valueString: model.blur!,
                        aliasTokenType: .boxShadow,
                        globalTokenType: .sizing,
                        prefixedWithDot: true
                    )
                    return """
                    .init(color: \(colorValue), radius: \(blur), position: .init(x: \(xPos), y: \(yPos)))
                    """
                }
               
                let dict = asDictionary(from:token.value[dictKey]).sortByAlphaNumeric()
                for item in dict {
                    guard isAliasIgnored(type: token.key, key: item.key) == false else { continue }
                    guard let shadow = item.value as? ShadowModel
                    else {
                        throw ErrorType.general("Wrong model")
                    }
                    let value = getBluShadowModel(shadow)
                    let variableName = getVariableName(item.key, tokenType: token.key)
                    let property = getProperty(
                        key: variableName,
                        value: value,
                        dataType: token.key.propertyTypeName
                    )
                    addTab(&result, n: startingIndentation + 1)
                    result += property
                    addNewline(&result)
                }
                addTab(&result, n: startingIndentation)
                result += "}"
                addNewline(&result)
                break
            case .any:
                break
            }
        }
        addTab(&result)
        result += "}"
        addNewline(&result)
        result += "}\n"
        result += "#endif\n"
        removePathAt(outputPath)
        do {
            try result.write(toFile: outputPath, atomically: true, encoding: .utf8)
        } catch {
            throw ErrorType.failWritingFile(error)
        }
    }
}
// MARK: Transform color values
private extension AliasTokenGenerator {
    static func flattenColor(dictionaryInput: TokenDict, startingIndentation: Int) throws -> String {
        var result = ""
        func getColorProp(key: String, color: ColorModel) throws -> String {
            let dataType = "SwiftUI.Color"
            let variableName = getVariableName(
                key,
                tokenType: .color
            )
            let globalAlias = try getValueFrom(
                valueString: color.colorAlias ?? "",
                aliasTokenType: .color,
                globalTokenType: .color
            )
            var property = getProperty(key: variableName, value: "." + globalAlias, dataType: dataType)
            if let colorHex = color.opacityHex {
                let opacity = String(Double(Int(colorHex, radix: 16) ?? 255))
                property += ".opacity(\(opacity)/255)"
            }
            return property
        }

        
        func flattenColorRec(keyPath: String, value: Any, level:Int, isLastIndex: Bool = false) throws {
            if value is ColorModel {
                addTab(&result, n: level)
                result += try getColorProp(key: keyPath, color: value as! ColorModel)
                if isLastIndex == false {
                    addNewline(&result)
                }
            }
            var dict = asDictionary(from: value).sortByAlphaNumeric()
            
            if dict.isEmpty == false {
                addTab(&result, n: level)
                let nameSpace = getNameSpace(key: keyPath.capitalized)
                result += nameSpace
                addNewline(&result)
                if dict.first?.value is ColorModel {
                    dict = dict.sorted(by: { lhs, rhs in
                        let a = lhs.value as! ColorModel
                        let b = rhs.value as! ColorModel
                        
                        return a.colorAlias?.compare(b.colorAlias ?? "", options: .numeric) == .orderedAscending
                    })
                }
                for (index, value) in dict.enumerated() {
                    let isChildLastIndex = index == dict.endIndex - 1
                    try flattenColorRec(keyPath: value.key, value: value.value, level: level + 1, isLastIndex: isChildLastIndex)
                }
                addNewline(&result)
                addTab(&result, n: level)
                result += "}"
                if isLastIndex == false {
                    addNewline(&result)
                }
            }
        }
        
        let sortedDict = dictionaryInput.sortByAlphaNumeric()
        for (index, value) in sortedDict.enumerated() {
            let isLastIndex = index == sortedDict.endIndex - 1
            try flattenColorRec(keyPath: value.key, value: value.value, level: startingIndentation, isLastIndex: isLastIndex)
        }
        
        return result
    }
}

// MARK: Utils
private extension AliasTokenGenerator {
    static func addTab(_ input: inout String, n: Int = 1){
        for _ in 0..<n {
            input += "\t"
        }
    }
    static func getTab(n: Int = 1) -> String {
        var tab = ""
        addTab(&tab, n:n)
        return tab
    }
    static func addNewline(_ input: inout String, n: Int = 1){
        for _ in 0..<n {
            input += "\n"
        }
    }
    static func getNameSpace(key: String) -> String {
        return "public struct \(key) {"
    }
    
    static func getVariableName(_ key: String, tokenType: AliasTokenType) -> String {
        var copy = key
        let reservedKeywords: Set<String> = .init([
            "default"
        ])
        if copy.first?.isNumber ?? false {
            copy = "_" + copy
        }
        if reservedKeywords.contains(copy) {
            copy = "`\(copy)`"
        }
        return copy
    }
    
    static func getValueFrom(valueString: Any, tokenType: AliasTokenType) throws -> String {
        guard let string = (valueString as? String)
        else { throw ErrorType.general("Expected value is string: \(String(describing: valueString))")}
        return try getValueFrom(valueString: string, aliasTokenType: tokenType)
    }
    
    static func getGlobalToken(
        _ valueString: String,
        aliasTokenType: AliasTokenType,
        globalTokenType: GlobalTokenType
    ) throws -> String {
        var valueString = valueString
        valueString.removeAll(where: {$0 == " "})
        let startCurlyIndex = valueString.firstIndex(of: "{")!
        let endCurlyIndex = valueString.firstIndex(of: "}")!
        
        let tokenStartIndex = valueString.index(after: startCurlyIndex)
        // Reminder that endIndex is like .end() iterator in C/C++
        // meaning they are past the last accessible index.
        var possibleGlobalToken = String(valueString[tokenStartIndex..<endCurlyIndex]).camelCased(with: "-", lowercase: false)

        // The string is {some-token.10}
        if startCurlyIndex == valueString.startIndex,
           endCurlyIndex == valueString.index(before: valueString.endIndex) {
            // Alias
            if aliasTokenType == .boxShadow {
                // TODO: This needs parser's refactoring
                possibleGlobalToken = possibleGlobalToken.camelCased(with: ".")
            }
            if globalTokenType == .color {
                let colorNamePrefix = "Color"
                possibleGlobalToken = tokenPrefix +  colorNamePrefix + possibleGlobalToken.capitalizingFirstLetter()
            } else {
                possibleGlobalToken = tokenPrefix + possibleGlobalToken.capitalizingFirstLetter()
            }
            guard GlobalTokenGenerator.availableGlobalTokens.contains(possibleGlobalToken) else {throw ErrorType.general("global alias not found: \(possibleGlobalToken)")}
            return possibleGlobalToken
        } else {
            // The string is {some-token.10}AB
            
            let suffixStartIndex = valueString.index(after: endCurlyIndex)
            let suffix = valueString[suffixStartIndex..<valueString.endIndex]
            if aliasTokenType == .boxShadow {
                // TODO: This needs parser's refactoring
                possibleGlobalToken = possibleGlobalToken.camelCased(with: ".")
            }
            var result = ""
            
            switch globalTokenType {
            case .color :
                let colorNamePrefix = "Color"
                possibleGlobalToken = tokenPrefix + colorNamePrefix + possibleGlobalToken.capitalizingFirstLetter()
                // If the last character is not "}", expect an alpha
                let alphaValue = String(Double(Int(suffix, radix: 16) ?? 255))
                result = possibleGlobalToken + ".opacity(\(alphaValue)/255)"
                
            case .sizing:
                possibleGlobalToken = tokenPrefix + possibleGlobalToken.capitalizingFirstLetter()
                if (suffix.first ?? " ") == "*" {
                    let multiplier = suffix[suffix.index(after: suffixStartIndex)..<suffix.endIndex]
                    result = "\(possibleGlobalToken) * \(multiplier)"
                } else {
                    throw ErrorType.general("Unknown value format")
                }
                
            default:
                possibleGlobalToken = tokenPrefix + possibleGlobalToken.capitalizingFirstLetter()
                result = possibleGlobalToken
            }
            
            guard GlobalTokenGenerator.availableGlobalTokens.contains(possibleGlobalToken)
            else {
                throw ErrorType.general("global alias not found: \(possibleGlobalToken)")
            }
            return result
        }
    }
    static func isPrimitiveType(value: String) -> Bool {
        if Double(value) != nil {
            return true
        }
        return false
    }
    
    /// Unfortunately this function has too many responsibilities.
    /// TODO: refactor this somehow
    /// This mainly will try to get the "value" of the global tokens given a "raw alias"
    /// Will always validate with the global tokens pool
    /// set globalTokenType to nil to look for global tokens without any special prefix
    /// e.g.:
    /// to get "bluSize10" the call is getValueFrom({size10},.sizing,nil)
    /// to get "bluColorBlue99) the call is getValueFrom({red.10}, .color, .color)
    ///
    /// - Parameters:
    ///   - valueString: rawValue of the alias, e.g. {size10}, {fontSize10}, {red99{, etc.
    ///   - aliasTokenType: the alias token type
    ///   - globalTokenType: the desired global token type, nil to ignore any special validation
    ///   - prefixedWithDot: whether to prefix the value with dot, given that the value is a token
    /// - Returns: string representation of desired global alias. e.g. blueRed99
    static func getValueFrom(
        valueString: String,
        aliasTokenType: AliasTokenType,
        globalTokenType: GlobalTokenType = .any,
        prefixedWithDot: Bool = false
    ) throws -> String {
        if let startCurly = valueString.firstIndex(of: "{"),
           let endCurly = valueString.firstIndex(of: "}"),
           startCurly != endCurly
        {
            let value = try getGlobalToken(
                valueString,
                aliasTokenType: aliasTokenType,
                globalTokenType: globalTokenType
            )
            
            if prefixedWithDot {
                return "." + value
            } else {
                return value
            }
        }
        else if valueString.last == "%"
        {
            var copy = valueString
            copy.removeLast()
            guard let value = Int(copy, radix: 10) else { throw ErrorType.general("Invalid percentage: \(valueString)") }
            return String(value)
            
        }
        else if isPrimitiveType(value: valueString)
        {
            return valueString
        }
        
        throw ErrorType.general("Unsupported value format: \(valueString)")
    }

    static func getProperty(key: String, value: String, dataType: String) -> String {
        return "public static let \(key): \(dataType) = \(value)"
    }
}

// MARK: Ignored alias
private extension AliasTokenGenerator {
    struct IgnoredAlias: Hashable {
        let type: AliasTokenType
        let key: String
    }
    static let ignoredAlias: Set<IgnoredAlias> = .init([
        .init(type: .borderRadius, key: "circle")
    ])
    
    static func isAliasIgnored(type: AliasTokenType, key: String) -> Bool {
        return ignoredAlias.contains(.init(type: type, key: key.lowercased()))
    }
}
