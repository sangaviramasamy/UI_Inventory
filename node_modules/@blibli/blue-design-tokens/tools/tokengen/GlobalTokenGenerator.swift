import Foundation
import CoreText
/// Adapted from BlueDLSTokenPackage

class GlobalTokenGenerator {
    private static let globalPrefix = "blu"
    static var availableGlobalTokensDict: [String:String] = [:]
    static var availableGlobalTokens: Set<String> = .init()
    static func generateColorAsset(resourcePath: String, libraryPath: String, tokenType: TokenType) throws {
        if tokenType == .global {
            let dict = try? getGlobalTokenDictionary()
            guard let dict else {return}
            // TODO: Refactor these later
            for token in dict {
                switch token.key {
                case .color:
                    try generateColorExtension(atPath: libraryPath, colors: token.value)
                case .fontFamilies:
                    let typefaceKey = "typeface"
                    let dict = asDictionary(from: token.value[typefaceKey])
                    try generateTypeface(atPath: libraryPath, fontFamilyDict: dict)
                case .fontSizes:
                    let fontSizeKey = "fontSize"
                    let dict = asDictionary(from: token.value[fontSizeKey])
                    try generateFontSize(atPath: libraryPath, fontSizes: dict)
                case .fontWeights:
                    let fontWeightKey = "fontWeight"
                    let dict = asDictionary(from: token.value[fontWeightKey])
                    try generateFontWeightToken(atPath: libraryPath, fontWeightDict: dict)
                case .lineHeights:
                    let lineHeightKey = "lineHeight"
                    let dict = asDictionary(from: token.value[lineHeightKey])
                    try generateLineHeight(atPath: libraryPath, lineHeightDict: dict)
                case .opacity:
                    let opacityKey = "opacity"
                    let dict = asDictionary(from: token.value[opacityKey])
                    try generateOpacity(atPath: libraryPath, opacityDict: dict)
                case .sizing:
                    let sizeKey = "size"
                    let dict = asDictionary(from: token.value[sizeKey])
                    try generateSize(atPath: libraryPath, sizeDict: dict)
                case .textDecoration:
                    let key = "textDecoration"
                    let dict = asDictionary(from: token.value[key])
                    try generateTextDecoration(atPath: libraryPath, dict: dict)
                default:
                    break
                }
            }
        } else {
            print("Alias")
        }
    }
}
// MARK: Colors
private extension GlobalTokenGenerator {
    static let colorNamePrefix = "Color" 
    static func generateColorExtension(atPath: String, colors: TokenDict) throws {
        let fileName = "Color+Global.swift"
        let outputPath = "\(atPath)/\(fileName)"
        let availibilityCheck = "@available(iOS 13.0, macOS 10.15, *)"
        // Prefixed with SwiftUI to avoid name collision
        let template = """
            /// Generated File
            #if canImport(SwiftUI)
            import SwiftUI
            \(availibilityCheck)
            // MARK: Blue 3.0 Color tokens
            public extension SwiftUI.Color {
            """
        
        let getProperty: (String, RGBA) -> String = { variableName, rgba in
            return "static let \(variableName): Self = .init(red: \(String(rgba.r))/255, green: \(String(rgba.g))/255, blue: \(String(rgba.b))/255, opacity: \(String(rgba.a))/255)"
        }

        let closing = "}\n#endif\n"
        var result = template
        for color in colors.sorted(by: { $0.key < $1.key }) {
            result += "\n\t// MARK: \(color.key.capitalized) Token"
            
            let colorTokenDict = (color.value as? [String: String]) ?? [:]
            let sortedDictionary = colorTokenDict.sorted(by: { $0.key.compare($1.key, options: .numeric) == .orderedAscending })
            for colorTokenItem in sortedDictionary {
                let colorToken = colorTokenItem.key
                let colorHexString = colorTokenItem.value
                let variableName = globalPrefix + colorNamePrefix + colorToken.capitalizingFirstLetter()
                availableGlobalTokens.insert(variableName)
                let rgba = getRGBAfromHexString(colorHexString) ?? .clear
                let hexString: String = String(format: "\"#%02x%02x%02x%02x\"", Int(rgba.r), Int(rgba.g), Int(rgba.b), Int(rgba.a))
                result += "\n\t" + "/// " + hexString
                result += "\n\t" + getProperty(variableName, rgba)
            }
            result += "\n"
        }
        result += closing
        removePathAt(outputPath)
        do {
            try result.write(toFile: outputPath, atomically: true, encoding: .utf8)
        } catch {
            throw ErrorType.failWritingFile(error)
        }
    }
}
// MARK: Font Family (Typeface)

extension GlobalTokenGenerator {
    static let availableTypefaces = {
        // force try intentional to prevent silent errors
        var fileNames = try! getAvailableFontFiles(path: blueFontDirPath)
        // remove font weight suffix
        var typefaces = Set(fileNames.map({ fileName in
            let fontName = String(fileName.split(separator: "-").first?.capitalized ?? "")
            return fontName
        }))
        typefaces.remove("")
        return typefaces
    }()
    /// Mapping of its variable name to its value
    /// E.g. ["typefaceBlibli":"Blibli"]
    private(set) static var availableTypefacesDictionary: [String: String] = [:]
    private static func generateTypeface(atPath: String, fontFamilyDict: TokenDict) throws {
        let typeName = "Typeface"
        let fileName = "\(typeName).swift"
        let outputPath = "\(atPath)/\(fileName)"
        let template = """
            /// Generated File
            // MARK: Blue 3.0 Font Families
            public enum \(typeName): String, CaseIterable {\n
            """
        
        let getProperty: (String, String) -> String = { variableName, value in
            return "case \(variableName) = \"\(value)\""
        }
        let closing = "}\n"
        var result = template
        
        for fontFamily in fontFamilyDict.sorted(by: { $0.key < $1.key }) {
            // value here is "blibli", "arial", "timesNewRoman", etc.
            let typeface = asString(from: fontFamily.value)
            guard availableTypefaces.contains(typeface) else { continue }
            let variableName = globalPrefix +  fontFamily.key.capitalizingFirstLetter()
            availableGlobalTokens.insert(variableName)
            availableTypefacesDictionary[variableName] = typeface
            result += "\t" + getProperty(variableName, typeface)
            result += "\n"
        }
        result += closing
        removePathAt(outputPath)
        do {
            try result.write(toFile: outputPath, atomically: true, encoding: .utf8)
        } catch {
            throw ErrorType.failWritingFile(error)
        }
    }
}
// MARK: Font Size

private extension GlobalTokenGenerator {
    static func generateFontSize(atPath: String, fontSizes: TokenDict) throws {
        let extendedType = GlobalTokenType.fontSizes.dataType
        let fileName = "\(extendedType)+GlobalFontSize.swift"
        let outputPath = "\(atPath)/\(fileName)"
        let template = """
            /// Generated File
            import Foundation
            // MARK: Blue 3.0 Font Size tokens
            public extension \(extendedType) {\n
            """
        
        let getProperty: (String, String) -> String = { variableName, size in
            return "static let \(variableName): Self = \(size)"
        }
        let closing = "}\n"
        var result = template
        
        for fontSize in fontSizes.sorted(by: { $0.key.compare($1.key, options: .numeric) == .orderedAscending }) {
            let fontSizeValue = asString(from: fontSize.value)
            let variableName = globalPrefix + fontSize.key.capitalizingFirstLetter()
            let docs = "/// \(fontSizeValue)\n"
            result += "\t" + docs
            result += "\t" + getProperty(variableName, fontSizeValue)
            result += "\n"

            availableGlobalTokens.insert(variableName)
            availableGlobalTokensDict[variableName] = fontSizeValue
        }
        result += closing
        removePathAt(outputPath)
        do {
            try result.write(toFile: outputPath, atomically: true, encoding: .utf8)
        } catch {
            throw ErrorType.failWritingFile(error)
        }
    }
}
// MARK: Font Weight

extension GlobalTokenGenerator {
    /** Available font weights taken from the available font files provided by blue-font
        
     // e.g.,  a json such as
     "font-weight": {
       "400": {
         "value": "Regular",
         "type": "fontWeights"
       }
     // will result in the following names:
     // fontWeight400 -> Regular.
     // In this case, "Regular" is the Font Weight's name. more appropriately, it should be font "style"
     // 400 is the value of the font weight.
     */
    static var availableFontTokens: Set<FontToken> = {
        // force try intentional to prevent silent errors
        var fileNames = try! getAvailableFontFiles(path: blueFontDirPath)
        let fontWeights = Set(fileNames.map({ fileName in
            // remove file extension
            let fontName = String(fileName.split(separator: ".").first ?? "")
            let fontFileNameTokens = fontName.split(separator: "-")
            // Remove the "blibli" format.
            let fontWeightName = fontFileNameTokens[1...].map({$0.capitalized}).joined(separator: "")
            return FontToken.init(
                typeface: fontFileNameTokens[0].capitalized,
                fileName: fileName,
                style: fontWeightName
            )
        }))
        return fontWeights
    }()
    private(set) static var availableFontWeightDictionary: [String: String] = [:]
    
    private static func loadFont(path: String) throws -> CGFont {
        guard let data = NSData(contentsOfFile: path) else {
            throw ErrorType.general("Font file not found at: \(path)")
        }
        let provider = CGDataProvider(data: data)
        guard let fontRef = CGFont(provider!) else {
            throw ErrorType.general("Failed to create CGFont from font data")
        }
        return fontRef
    }
    
    private static func generateFontWeightToken(atPath: String, fontWeightDict: TokenDict) throws {
        /**
         NOTE ABOUT FONT LOADING:
         Since iOS does not find the font based on the loaded font's filename, we need to check out the loadable name using swift's internal libraries
         so other swift project can actually load the files
         */
        // MARK: Human Readable Font Weights
        let fontFilesDirectory = blueFontDirPath
        let fileName = "FontWeight.swift"
        let outputPath = "\(atPath)/\(fileName)"
        let template = """
            /// Generated File
            // MARK: Blue 3.0 Font Families
            public enum FontWeight: String, CaseIterable {\n
            """
        
        let getProperty: (String, String) -> String = { variableName, value in
            return "case \(variableName) = \"\(value)\""
        }
        let getVariableName: (TokenDict.Element) -> String = { token in
            return globalPrefix + token.key.capitalizingFirstLetter()
        }
        let closing = "}\n"
        var result = template
        var validFontWeights: TokenDict = [:]
        for font in fontWeightDict {
            let availableFont = availableFontTokens.first { token in
                (token.style ?? "") == asString(from: font.value)
            }
            
            if let availableFont {
                var copy = availableFont
                
                //try getting the weight
                var keyCopy = font.key
                keyCopy.removeAll(where: {$0.isLetter})
                let tokenName = getVariableName(font)

                copy.tokenName = tokenName
                copy.weight = Int(keyCopy)
                copy.postScriptName = ((try! loadFont(path: fontFilesDirectory + "/" + copy.fileName)).postScriptName! as String)
                                       
                availableFontTokens.remove(availableFont)
                availableFontTokens.insert(copy)
                validFontWeights[font.key] = font.value
            }
        }
          
        for fontWeight in validFontWeights.sortByAlphaNumeric() {
            let val = asString(from: fontWeight.value)
            let variableName = getVariableName(fontWeight)
            availableGlobalTokens.insert(variableName)
            availableFontWeightDictionary[variableName] = val
            result += "\t" + "/// \(val)\n"
            result += "\t" + getProperty(variableName, val)
            result += "\n"
            
            availableGlobalTokensDict[variableName] = val
        }
        result += closing

        func getLoadableFontExtension() -> String {
            // MARK: Swift loadable font identifiers
            var result = ""
            let template = """
            public extension FontWeight {
            \tvar loadableFontSuffix: String {
            \t\tswitch self {
            """
            for font in availableFontTokens.sorted(by: {$0.tokenName ?? "" < $1.tokenName ?? ""}) {
                if let identifier = font.postScriptName,
                    let tokenName = font.tokenName {
                    // Remove blibli from the identifier
                    let weight = identifier.split(separator: "-")[1...].joined(separator: "-")
                    result += "\t\t"
                    result += """
                    case .\(tokenName): return "\(weight)"\n
                    """
                }
            }
            guard result.isEmpty == false else { return "" }
            result = "\n" + template + "\n" + result
            result += "\t\t}\n"
            result += "\t}\n"
            result += "}"
            return result
        }
        result += getLoadableFontExtension()
        result += "\n"
        removePathAt(outputPath)
        do {
            try result.write(toFile: outputPath, atomically: true, encoding: .utf8)
        } catch {
            throw ErrorType.failWritingFile(error)
        }
      
    }
}
// MARK: Line Height

private extension GlobalTokenGenerator {
    static func generateLineHeight(atPath: String, lineHeightDict: TokenDict) throws {
        let extendedType = GlobalTokenType.lineHeights.dataType
        let fileName = "\(extendedType)+GlobalLineHeight.swift"
        let outputPath = "\(atPath)/\(fileName)"
        let template = """
            /// Generated File
            import Foundation
            // MARK: Blue 3.0 Line Height tokens
            public extension \(extendedType) {\n
            """
        
        let getProperty: (String, String) -> String = { variableName, value in
            return "static let \(variableName): Self = \(value)"
        }
        let closing = "}\n"
        var result = template
        
        for lineHeight in lineHeightDict.sorted(by: { $0.key.compare($1.key, options: .numeric) == .orderedAscending }) {
            let variableName = globalPrefix + lineHeight.key.capitalizingFirstLetter()
            availableGlobalTokens.insert(variableName)
            let value = asString(from: lineHeight.value)
            let docs = "/// \(value)\n"
            result += "\t" + docs
            result += "\t" + getProperty(variableName, value)
            result += "\n"
        }
        result += closing
        removePathAt(outputPath)
        do {
            try result.write(toFile: outputPath, atomically: true, encoding: .utf8)
        } catch {
            throw ErrorType.failWritingFile(error)
        }
    }
}
// MARK: Opacity

private extension GlobalTokenGenerator {
    static func generateOpacity(atPath: String, opacityDict: TokenDict) throws {
        let extendedType = GlobalTokenType.opacity.dataType
        let fileName = "\(extendedType)+GlobalOpacity.swift"
        let outputPath = "\(atPath)/\(fileName)"
        let template = """
            /// Generated File
            import Foundation
            // MARK: Blue 3.0 Opacity tokens
            public extension \(extendedType) {\n
            """
        
        let getProperty: (String, String) -> String = { variableName, value in
            
            return "static let \(variableName): Self = \(value)"
        }
        let closing = "}\n"
        var result = template
        
        for opacity in opacityDict.sorted(by: { $0.key.compare($1.key, options: .numeric) == .orderedAscending }) {
            let opacityKey = opacity.key
            var opacityValue = asString(from: opacity.value)
            if opacityValue.hasSuffix("%") {
                opacityValue.removeLast()
                opacityValue = String((Double(opacityValue) ?? 100) / 100)
            }
            let variableName = globalPrefix + opacityKey.capitalizingFirstLetter()
            availableGlobalTokens.insert(variableName)
            result += "\t" + "/// \(opacityValue)\n"
            result += "\t" + getProperty(variableName, opacityValue)
            result += "\n"
            availableGlobalTokensDict[variableName] = opacityValue

        }
        result += closing
        removePathAt(outputPath)
        do {
            try result.write(toFile: outputPath, atomically: true, encoding: .utf8)
        } catch {
            throw ErrorType.failWritingFile(error)
        }
    }
}
// MARK: Size

private extension GlobalTokenGenerator {
    static func generateSize(atPath: String, sizeDict: TokenDict) throws {
        let extendedType = GlobalTokenType.sizing.dataType
        let fileName = "\(extendedType)+GlobalSize.swift"
        let outputPath = "\(atPath)/\(fileName)"
        let template = """
            /// Generated File
            import Foundation
            // MARK: Blue 3.0 Size tokens
            public extension \(extendedType) {\n
            """
        
        let getProperty: (String, String) -> String = { variableName, value in
            return "static let \(variableName): Self = \(value)"
        }
        let closing = "}\n"
        var result = template
        
        for size in sizeDict.sorted(by: { $0.key.compare($1.key, options: .numeric) == .orderedAscending }) {
            let variableName = globalPrefix + size.key.capitalized
            availableGlobalTokens.insert(variableName)
            let value = asString(from: size.value)
            result += "\t" + "/// \(value)\n"
            result += "\t" + getProperty(variableName, value)
            result += "\n"
            availableGlobalTokensDict[variableName] = value

        }
        result += closing
        removePathAt(outputPath)
        do {
            try result.write(toFile: outputPath, atomically: true, encoding: .utf8)
        } catch {
            throw ErrorType.failWritingFile(error)
        }
    }
}
// MARK: TextDecoration

private extension GlobalTokenGenerator {
    private static func generateTextDecoration(atPath: String, dict: TokenDict) throws {
        let fileName = "TextDecoration.swift"
        let outputPath = "\(atPath)/\(fileName)"
        let template = """
            /// Generated File
            // MARK: Blue 3.0 Text Decoration
            public enum TextDecoration: String {\n
            """
        
        let getProperty: (String, String) -> String = { variableName, value in
            let docs = "/// \(value)\n"
            return docs + "case \(variableName) = \"\(value)\""
        }
        let closing = "}\n"
        var result = template
        
        for textDecoration in dict.sorted(by: { $0.key < $1.key }) {
            let variableName = globalPrefix + textDecoration.key.capitalizingFirstLetter()
            availableGlobalTokens.insert(variableName)
            result += "\t" + getProperty(variableName, asString(from: textDecoration.value))
            result += "\n"
        }
        result += closing
        removePathAt(outputPath)
        do {
            try result.write(toFile: outputPath, atomically: true, encoding: .utf8)
        } catch {
            throw ErrorType.failWritingFile(error)
        }
    }
}
