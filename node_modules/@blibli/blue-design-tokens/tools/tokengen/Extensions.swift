//
//  Extensions.swift
//  
//
//  Created by Aldrian Kwantawijaya on 18/04/23.
//
import Foundation
/// Stolen from BlueDLSTokenPackage
extension Any? {
    func asString() -> String {
        self as? String ?? ""
    }
}

extension String: LocalizedError {
    public var errorDescription: String? { return self }
}

extension String {
    func getFirstWord(separator: Character) -> String {
        String(describing: self.split(separator: ".").first ?? "")
    }
    
    func indent(with indentation: String) -> String {
        return self
            .components(separatedBy: "\n")
            .map { line in line .isEmpty ? "" : "\(indentation)\(line)" }
            .joined(separator: "\n")
    }
    
    /// Converts a string to camel case format with a specified separator.
    ///
    /// - Parameters:
    ///   - separator: The separator character used to split the string into parts.
    ///   - lowercase: A flag indicating whether to convert the resulting string to lowerCamelCase format (default is `true`).
    ///
    /// - Returns: The string converted to camel case format.
    ///
    /// - Important: The resulting string will have the first word capitalized if `lowercase` is `false`.
    ///
    /// - Example:
    ///   ```
    ///   let inputString = "hello_world_example"
    ///
    ///   let camelCaseString = inputString.camelCased(with: "_")
    ///   print(camelCaseString) // "helloWorldExample"
    ///
    ///   let capitalizedCamelCaseString = inputString.camelCased(with: "_", lowercase: false)
    ///   print(capitalizedCamelCaseString) // "HelloWorldExample"
    ///   ```
    func camelCased(with separator: Character, lowercase: Bool = true) -> String {
        if lowercase {
            return self.lowercased()
                .split(separator: separator)
                .enumerated()
                .map { $0.offset > 0 ? $0.element.capitalized : $0.element.lowercased() }
                .joined()
        } else {
            return self.split(separator: separator)
                .enumerated()
                .map { $0.offset > 0 ? $0.element.capitalized : String($0.element)}
                .joined()
        }
        
    }
    
    /// Converts a PascalCase formatted string to a capitalized string separated by spaces.
    ///
    /// - Parameter inputString: The PascalCase formatted input string.
    /// - Returns: The capitalized string with spaces separating the words.
    ///
    /// - Example:
    ///   ```
    ///   let pascalCaseString = "PascalCaseExample"
    ///
    ///   let capitalizedString = convertPascalCaseToCapitalized(inputString: pascalCaseString)
    ///   print(capitalizedString) // "Pascal Case Example"
    ///   ```
    func pascalToLower(separator: Character = " ") -> String {
        let regex = try! NSRegularExpression(pattern: "(?<!^)([A-Z])", options: [])
        let range = NSRange(location: 0, length: self.utf16.count)
        let modifiedString = regex.stringByReplacingMatches(
            in: self,
            options: [],
            range: range,
            withTemplate: "\(separator)$0"
        )
        return modifiedString.lowercased()
    }
    
    func capitalizingFirstLetter() -> String {
        return prefix(1).capitalized + dropFirst()
    }
    
    mutating func capitalizeFirstLetter() {
        self = self.capitalizingFirstLetter()
    }
}

extension Encodable {
  var dictionary: [String: Any] {
      guard let data = try? JSONEncoder().encode(self) else { return [:] }
      return (try? JSONSerialization.jsonObject(with: data, options: .allowFragments)).flatMap { $0 as? [String: Any] } ?? [:]
  }
}

enum DictSortByType {
    case key
    case value
}

extension Dictionary where Key: StringProtocol {
    func sortByAlphaNumeric(by: DictSortByType = .key, getValueComparator: ((Value) -> String?)? = nil) -> [(key: Key, value: Value)] {
        self.sorted(
            by: { lhs, rhs in
                var lKey = String(lhs.key)
                var rKey = String(rhs.key)
                switch by {
                case .value:
                        lKey = getValueComparator?(lhs.value) ?? lKey
                        rKey = getValueComparator?(rhs.value) ?? rKey
                case .key:
                    break
                }
                return lKey.compare(rKey, options: .numeric) == .orderedAscending
            }
        )
    }
}
///
extension Dictionary where Key: CustomStringConvertible {
    func sortByAlphaNumeric(by: DictSortByType = .key, getValueComparator: ((Value) -> String?)? = nil) -> [(key: Key, value: Value)] {
        self.sorted(
            by: { lhs, rhs in
                var lKey = String(describing: lhs.key)
                var rKey = String(describing: rhs.key)
                switch by {
                case .value:
                        lKey = getValueComparator?(lhs.value) ?? lKey
                        rKey = getValueComparator?(rhs.value) ?? rKey
                case .key:
                    break
                }
                return lKey.compare(rKey, options: .numeric) == .orderedAscending
            }
        )
    }
}
