import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import org.json.JSONException
import org.json.JSONObject
import java.io.*
import java.util.HashMap

class JsonUtility {
    companion object {
        const val SLASH = "/"
        const val GLOBAL_TOKEN = "globalToken"
        const val ALIAS_TOKEN = "aliasToken"
        const val GLOBAL_TOKEN_SLASH = "globalToken/"
        const val ALIAS_TOKEN_SLASH = "aliasToken/"
        const val TYPOGRAPHY = "typography"
        const val COLOR = "color"
        const val OPACITY = "opacity"
        const val SPREAD = "spread"
        const val BLUR = "blur"
        const val X = "x"
        const val Y = "y"
        const val BOX_SHADOW = "boxShadow"
        const val SIZING = "sizing"
        const val BOARDER_RADIUS = "borderRadius"
        const val SPACING = "spacing"
        const val LINE_HEIGHT = "lineHeight"
        const val FONT_WEIGHT = "fontWeight"
        const val FONT_SIZE = "fontSize"
        const val FONT_SIZE2 = "font-size"
        const val FONT_FAMILY = "fontFamily"
        const val LINE_HEIGHTS = "lineHeights"
        const val FONT_SIZES = "fontSizes"
        const val FONT_FAMILIES = "fontFamilies"
        const val TYPE = "type"
        const val VALUE = "value"
        const val ALIAS_TOKEN_TYPOGRAPHY_PATH = "aliasToken/typography/"
        const val GLOBAL_TOKEN_SIZE_PATH = "globalToken/size/"
    }

    private var aliasValueHashMap: HashMap<String, Any> = hashMapOf()
    private var globalValueHashMap: HashMap<String, Any> = hashMapOf()
    private var opacityHashMap: HashMap<String, Int> = hashMapOf()
    private var visitedHashMap: HashMap<String, JSONObject> = hashMapOf()
    fun jsonConversion(input: String, output: String) {
        initOpacityHashMap()
        try {
            val inputStream = FileInputStream(input)
            val inputStreamReader = InputStreamReader(inputStream)
            val bufferedReader = BufferedReader(inputStreamReader)
            val jsonString: String = bufferedReader.use { it.readText() }
            val json = JSONObject(jsonString)
            for (key in listOf(GLOBAL_TOKEN, ALIAS_TOKEN)) {
                jsonToIntermediateHashMapImplementation(
                    json.get(key) as JSONObject, key, prefix = key
                )
            }
        } catch (e: IOException) {
            e.printStackTrace()
        } catch (e: JSONException) {
            e.printStackTrace()
        } catch (e: Exception) {
            e.printStackTrace()
        }
        runBlocking {
            launch {
                outputCreation(aliasValueHashMap)
            }
            launch {
                outputCreation(globalValueHashMap)
            }
        }
        val finalJSON = JSONObject()
        finalJSON.put(ALIAS_TOKEN, visitedHashMap[ALIAS_TOKEN_SLASH]?.get(ALIAS_TOKEN))
        finalJSON.put(GLOBAL_TOKEN, visitedHashMap[GLOBAL_TOKEN_SLASH]?.get(GLOBAL_TOKEN))
        val jsonString = finalJSON.toString()

        try {
            val file = File(output)
            if (!file.exists()) {
                file.createNewFile()
            }
            file.writeText(jsonString)
            println("Output json file generated successfully........")
        } catch (exception: Exception) {
            exception.printStackTrace()
        }
    }

    /**
     * Initializing the existing opacity values
     */
    private fun initOpacityHashMap() {
        opacityHashMap.apply {
            put("FF", 100)
            put("F2", 95)
            put("E6", 90)
            put("D9", 85)
            put("CC", 80)
            put("BF", 75)
            put("B3", 70)
            put("A6", 65)
            put("99", 60)
            put("8C", 55)
            put("80", 50)
            put("73", 45)
            put("66", 40)
            put("59", 35)
            put("4D", 30)
            put("40", 25)
            put("33", 20)
            put("26", 15)
            put("1A", 10)
            put("0D", 5)
            put("00", 0)
        }
    }

    /**
    * Iterating through all the input JSON file keys
    * Storing the modified values in intermediate hashmap(aliasValueHashMap, globalValueHashMap)
    */
    private fun jsonToIntermediateHashMapImplementation(
        childJsonObject: JSONObject, parent: String, superParent: String = "", prefix: String = ""
    ) {
        val arrayListOfChildKeys = ArrayList<String>()
        val listOfKeys = childJsonObject.keys()
        for (key in listOfKeys) {
            arrayListOfChildKeys.add(key)
        }
        if (arrayListOfChildKeys.any { it == TYPE }) {
            when (childJsonObject.get(TYPE)) {
                COLOR -> if (!prefix.contains(GLOBAL_TOKEN)) {
                    colorImplementation(childJsonObject, VALUE, prefix)
                } else {
                    globalValueHashMap["$GLOBAL_TOKEN_SLASH$COLOR$SLASH$superParent$parent"] =
                        childJsonObject.get(VALUE).toString()
                }

                FONT_FAMILIES -> {
                    if (!prefix.contains(GLOBAL_TOKEN)) {
                        val list = (childJsonObject.get(VALUE) as String).getListAfterRemovingBraces()
                        aliasValueHashMap[prefix] = list[0]
                    }
                }

                TYPOGRAPHY -> {
                    val valueObject = childJsonObject.get(VALUE) as JSONObject
                    for (valueChildKey in valueObject.keys()) {
                        val list = valueChildKey.getListAfterRemovingBracesAndDot(valueObject)
                        when (valueChildKey) {
                            FONT_FAMILY -> {
                                aliasValueHashMap["$ALIAS_TOKEN_TYPOGRAPHY_PATH$parent$SLASH$valueChildKey"] =
                                    list[1]
                            }

                            FONT_WEIGHT -> {
                                aliasValueHashMap["$ALIAS_TOKEN_TYPOGRAPHY_PATH$parent$SLASH$valueChildKey"] =
                                    list[1].toInt()
                            }

                            LINE_HEIGHT, FONT_SIZE -> {
                                aliasValueHashMap["$ALIAS_TOKEN_TYPOGRAPHY_PATH$parent$SLASH$valueChildKey"] =
                                    "$valueChildKey${list[1]}"
                            }

                            else -> {
                                val valueString = valueObject.get(valueChildKey) as String
                                aliasValueHashMap["$ALIAS_TOKEN_TYPOGRAPHY_PATH$parent$SLASH$valueChildKey"] =
                                    valueString
                            }
                        }
                    }
                }

                SIZING -> {
                    if (!prefix.contains(GLOBAL_TOKEN)) {
                        sizeTypeImplementation(childJsonObject, prefix)
                    } else {
                        globalValueHashMap["$GLOBAL_TOKEN_SIZE_PATH$superParent$parent"] =
                            childJsonObject.get(VALUE).toString().toInt()
                    }
                }

                SPACING -> {
                    sizeTypeImplementation(childJsonObject, prefix)
                }

                BOARDER_RADIUS -> {
                    if (parent != "circle") {
                        sizeTypeImplementation(childJsonObject, prefix)
                    } else {
                        aliasValueHashMap[prefix] = childJsonObject.get(VALUE) as String
                    }
                }

                OPACITY -> {
                    if (!prefix.contains(GLOBAL_TOKEN)) {
                        val list = VALUE.getListAfterRemovingBracesAndDot(childJsonObject)
                        aliasValueHashMap[prefix] = list[1].toInt()
                    }
                }

                LINE_HEIGHTS -> {
                    globalValueHashMap["$GLOBAL_TOKEN_SLASH$LINE_HEIGHT$SLASH$LINE_HEIGHT$parent"] =
                        childJsonObject.get(VALUE).toString().toInt()
                }

                FONT_SIZES -> {
                    globalValueHashMap["$GLOBAL_TOKEN_SLASH$FONT_SIZE2$SLASH$FONT_SIZE$parent"] =
                        childJsonObject.get(VALUE).toString().toInt()
                }

                BOX_SHADOW -> {
                    val valueObject = childJsonObject.get(VALUE) as JSONObject
                    for (valueChildren in valueObject.keys()) {
                        when (valueChildren) {
                            X, Y, BLUR -> {
                                boxShadowImplementation(valueObject, valueChildren, prefix)
                            }

                            SPREAD -> {
                                aliasValueHashMap["$prefix$SLASH$valueChildren"] =
                                    valueObject.get(valueChildren) as String
                            }

                            COLOR -> {
                                colorImplementation(valueObject, valueChildren, prefix)
                            }
                        }
                    }
                }
            }
        } else {
            for (i in arrayListOfChildKeys.indices) {
                val key = arrayListOfChildKeys[i]
                val value = childJsonObject.get(key)
                if (value is JSONObject) {
                    jsonToIntermediateHashMapImplementation(value, key, parent, "$prefix/$key")
                }
            }
        }
    }

    /**
    * Implementation for type = color
    */
    private fun colorImplementation(childObject: JSONObject, key: String, prefix: String) {
        val list = (childObject.get(key) as String).getListAfterRemovingBraces()
        aliasValueHashMap["$prefix$SLASH$key"] = list[0].replace(".", "")
        aliasValueHashMap["$prefix$SLASH$OPACITY"] = opacityHashMap[list.getIndex()] as Int
    }

    /**
    * Implementation for type = sizing
    */
    private fun sizeTypeImplementation(childJsonObject: JSONObject, prefix: String) {
        val list = (childJsonObject.get(VALUE) as String).getListAfterRemovingBraces()
        aliasValueHashMap[prefix] = list[0].replace(".", "")
    }

    /**
    * Implementation for type = boxShadow
    */
    private fun boxShadowImplementation(
        valueObject: JSONObject, valueChildren: String, prefix: String
    ) {
        val valueString = valueObject.get(valueChildren) as String
        val listOfValues = valueString.split("{", "}", "*").toMutableList()
        listOfValues.removeAll(listOf(""))
        if (listOfValues.size > 1) {
            val keyToGetSizeValue = "$GLOBAL_TOKEN_SIZE_PATH${listOfValues[0].replace(".", "")}"
            aliasValueHashMap["$prefix$SLASH$valueChildren"] =
                ((globalValueHashMap[keyToGetSizeValue] as Int) * listOfValues[1].toDouble())
        } else {
            val listOfSizeValues = valueChildren.getListAfterRemovingBracesAndDot(valueObject)
            if (listOfSizeValues.size > 1) {
                val keyToGetSizeValue =
                    "$GLOBAL_TOKEN_SIZE_PATH${listOfSizeValues[0]}${listOfSizeValues[1]}"
                aliasValueHashMap["$prefix$SLASH$valueChildren"] =
                    ((globalValueHashMap[keyToGetSizeValue] as Int).toDouble())
            } else {
                aliasValueHashMap["$prefix$SLASH$valueChildren"] = valueString.toDouble()
            }
        }
    }

    /**
    * logic to create output JSON file
    */
    private fun outputCreation(valueHashMap: HashMap<String, Any>) {
        valueHashMap.keys.sorted().forEach { jsonKey ->
            var listOfParentKeys: List<String> = jsonKey.split(SLASH)
            var prefix = ""
            var parentPrefix = ""
            for (i in 0 until listOfParentKeys.size - 1) {
                prefix = "$prefix${listOfParentKeys[i]}$SLASH"
                if (!visitedHashMap.contains(prefix)) {
                    val jsonObject = JSONObject()
                    val jsonEmpty = JSONObject()
                    jsonObject.put(listOfParentKeys[i], jsonEmpty)
                    visitedHashMap[prefix] = jsonObject
                    if (i != 0) {
                        val parentObject =
                            visitedHashMap[parentPrefix]?.get(listOfParentKeys[i - 1]) as JSONObject
                        parentObject.put(listOfParentKeys[i], jsonObject.get(listOfParentKeys[i]) as JSONObject)
                    }
                }
                parentPrefix = prefix
            }
            val value: Any? = valueHashMap[jsonKey]
            when (value) {
                is String -> Unit
                is Int -> Unit
                is Double -> Unit
            }
            listOfParentKeys = listOfParentKeys.reversed()
            listOfParentKeys.apply {
                (this.subList(1, this.size).reversed().joinToString(SLASH) + SLASH).let {
                    var tempJsonObject2 = JSONObject()
                    val jsonObject: JSONObject
                    if (visitedHashMap[it]?.get(this[1]) !is JSONObject) {
                        tempJsonObject2.put(this[0], value)
                        jsonObject = (visitedHashMap[it])!!
                        jsonObject.put(this[1], tempJsonObject2)
                    } else {
                        tempJsonObject2 = visitedHashMap[it]?.get(this[1]) as JSONObject
                        tempJsonObject2.put(this[0], value)
                    }
                }
            }
        }
    }
}

private fun List<String>.getIndex() = if (this.size == 2) {
    this[1].uppercase()
} else {
    "00"
}

private fun String.getListAfterRemovingBracesAndDot(jsonObject: JSONObject): List<String> {
    (jsonObject.get(this) as String).split("{", "}", ".").toMutableList().apply {
        removeAll(listOf(""))
        return this
    }
}

private fun String.getListAfterRemovingBraces(): List<String> {
    this.split("{", "}").toMutableList().apply {
        removeAll(listOf(""))
        return this
    }
}