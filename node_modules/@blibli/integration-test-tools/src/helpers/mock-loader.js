const pathUtil = require('../utils/path')
const chalk = require('chalk')
const globToRegex = require('glob-to-regexp')
const isGlob = require('is-glob')
const mockUrls = require('./mock-urls')
const mockMatcher = require('./mock-matcher')
require = require('esm')(module)
const {mainUi: mainUiConfig, app: appConfig} = require('./blibli-integration-test.config')
const { fileJsExists } = require('../utils/fs')
const { isDocker } = require('../utils/container.js')
const { isRegExp, isString } = require('../utils/type.js')
const { deepSortAndStringify, constructQueryParams } = require('../utils/object.js')
const isEqual = require('lodash.isequal')
const { _isAPICall } = require('./api-call-handler.js')

function getMockLoader () {
  let collabMocks = []
  let isInSession = false
  const MOCK_SETTER_FNS = {
    true: _setRegexMockEntry,
    false: _setMockEntry
  }
  const mocks = {
    session: new Map(),
    updated: new Map(),
    original: new Map()
  }
  const regexMocks = {
    session: new Map(),
    updated: new Map(),
    original: new Map()
  }
  const matchingStrategies = [
    { findMatch: mockMatcher.findExactMock, source: mocks },
    { findMatch: mockMatcher.findMatchRegexMock, source: regexMocks }
  ]

  function _loadMainUiMocks () {
    if (!mainUiConfig) return
    const path = mainUiConfig.mockPath || 'integrations/_blibli/ui-main/src/api-mock/index'
    // load mainUi mocks
    const mainMockPath = pathUtil.getPath(path)
    let mainMocks = []
    if (fileJsExists(mainMockPath)) {
      mainMocks = require(mainMockPath).default
    }
    collabMocks = collabMocks.concat(mainMocks)
    console.log(chalk.blue('UI Main mock file loaded:', path))
  }

  function _loadMock (mockPath) {
    const collabMockPath = pathUtil.getPath(mockPath)
    if (!fileJsExists(collabMockPath)) return

    const mocks = require(collabMockPath).default
    collabMocks = collabMocks.concat(mocks)
    console.log(chalk.green('Collab mock file loaded:', mockPath))
  }

  function _loadCollabMocks () {
    // if already loaded, skip
    if (collabMocks.length) {
      return
    }
    // load app mocks
    const mainUiMocks = _loadMainUiMocks()

    const paths = [].concat(appConfig.mockPath, appConfig.mockPaths)
      .filter(i => i)
    paths.forEach(_loadMock)
  }

  function _setMockEntry (mock, type = 'original') {
    const key = mock.url
    const entry = mocks[type].get(key) || {
      url: key,
      list: []
    }
    const values = mock.param_values || mock.body || {}
    const paramValuesStr = deepSortAndStringify(values)

    if (type !== 'original') {
      const duplicate = mockMatcher.findMatchInEntry(entry, {
        method: mock.method,
        body: paramValuesStr
      })

      entry.list = entry.list.filter(e => e !== duplicate)
    }

    entry.list.push({
      ...mock,
      param_values_str: paramValuesStr
    })
    mocks[type].set(key, entry)
  }

  function _setRegexMockEntry (mock, type = 'original') {
    const regexKey = isString(mock.url) ? globToRegex(mock.url) : mock.url
    const entry = {
      url: mock.url,
      list: []
    }
    const values = mock.param_values || mock.body || {}

    entry.list.push({
      ...mock,
      param_values_str: deepSortAndStringify(values)
    })
    regexMocks[type].set(regexKey, entry)
  }

  function _isPatternMockUrl (url) {
    return isGlob(url) || isRegExp(url)
  }

  function _assignMock (mock, type) {
    const isPatternMock = _isPatternMockUrl(mock.url)
    const fn = MOCK_SETTER_FNS[isPatternMock]

    fn(mock, type)
  }

  function _printDiff ({ key, method, body }, match) {
    if (isDocker) return
    if (!match && method === 'GET') return

    const queries = key?.split('?')[1] || {}
    const queryParams = queries ? constructQueryParams(queries) : {}

    const req = { key, method, body }
    const mock = {
      key: match?.url,
      method: match?.method,
      body: match?.param_values_str
    }
    const isIdentical = isEqual(req, mock)

    if (isIdentical) return

    console.log(chalk.yellow('REQUESTED DATA\n'))
    console.log(chalk.yellow('url: ', key))
    console.log(chalk.yellow('Method: ', method))
    console.log(chalk.yellow('Body: ', body))
    if (queryParams) console.log(
      chalk.yellow('Query Params: ', queryParams))
    console.log(chalk.yellow('----------------------------------------'))

    if (match) {
      console.log(chalk.green('MOCK FOUND\n'))
      console.log(chalk.green('url: ', match.url))
      console.log(chalk.green('Method: ', match.method))
      console.log(chalk.green('Body: ', match.param_values_str))
      if (match.queryParams) console.log(
        chalk.green('Query Params: ', deepSortAndStringify(match.queryParams)))
    } else {
      console.log(chalk.red('MOCK NOT FOUND'))
    }

    console.log(chalk.yellow('========================================\n\n'))
  }

  function _getRouteInMap ({ key, method, body }) {
    let result

    for (const strategy of matchingStrategies) {
      result = strategy.findMatch(strategy.source, { key, method, body })
      if (result) {
        break
      }
    }

    _printDiff({ key, method, body }, result)

    return result
  }

  async function mockApi (context) {
    // load mock response
    await context.route('**', async (route, request) => {
      // if it's a page view, continue routing
      if (request.isNavigationRequest()) {
        route.continue()
        return
      }
      const url = urlFilter(request.url())
      const headers = request.headers()

      let origin = null
      try {
        const urlObj = new URL(headers.referer)
        origin = urlObj.origin
      } catch (e) {}

      // construct key with referer as baseurl
      // we remove the baseurl since our mock url has no baseurl
      const key = ~url.indexOf(origin) ? url.replace(origin, '') : url

      const method = request.method()
      const body = request.postData()

      const found = _getRouteInMap({
        key,
        method,
        body
      })

      if (!found) {
        const isAPICall = _isAPICall(url)
        if (isAPICall) {
          route.abort('aborted')
          return
        }
        route.continue()
        return
      }

      const delay = found.delay || 0
      setTimeout(_ => {
        route.fulfill({
          status: found.status || 200,
          contentType: found.contentType || 'application/json',
          body: JSON.stringify(found.response),
          headers: found.response_header || {}
        })
      }, delay)
    })

    for (const i in mockUrls.abortUrls) {
      await context.route(mockUrls.abortUrls[i], route => route.abort())
    }
  }

  function urlFilter (url) {
    const urlOrigin = new URL(url)
    const params = urlOrigin.searchParams
    // remove ?nothirdparty query params for pyeongyang projects (if any)
    if (params.has("nothirdparty")) {
      params.delete("nothirdparty")
      return `${urlOrigin.origin}${urlOrigin.pathname}?${params.toString()}`
    }
    return url
  }

  function updateMock (route) {
    const mockType = isInSession ? 'session' : 'updated'
    _assignMock(route, mockType)
  }

  function resetMock () {
    mocks.updated = new Map()
    mocks.session = new Map()
  }

  function resetSessionMock () {
    mocks.session = new Map()
  }

  function startSession () {
    isInSession = true
  }

  function endSession () {
    isInSession = false
  }

  function initMock () {
    _loadCollabMocks()

    collabMocks
      .forEach(mock => _assignMock(mock, 'original'))
  }

  return {
    mockApi,
    updateMock,
    resetMock,
    resetSessionMock,
    startSession,
    endSession,
    initMock
  }
}
module.exports = {
  getMockLoader
}
