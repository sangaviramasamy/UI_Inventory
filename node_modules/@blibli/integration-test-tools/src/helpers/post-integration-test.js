const fse = require('fs-extra')
const chalk = require('chalk')
const path = require('path')
const pathUtil = require('../utils/path')
const { unitTest: unitTestConfig } = require('./blibli-integration-test.config')

const FILE_SEP = path.sep

function _checkFilesExist (paths) {
  return paths.every(path => {
    const exist = fse.existsSync(pathUtil.getPath(path))
    if (!exist) {
      console.log(chalk.red('File not found: ', path))
    }
    return exist
  })
}

function _adjustIntegrationCoverageDataStructure () {
  const integrationCov = _getIntegrationCoverage()
  const hasData = Object.entries(integrationCov).some(entry => {
    const firstEntry = entry[1] || {}
    return firstEntry.data
  })

  if (!hasData) {
    return
  }

  // start
  const newCoverage = Object.entries(integrationCov).reduce((acc, [key, value]) => {
    acc[key] = value.data
    return acc
  }, {})
  _updateIntegrationCoverageCache(newCoverage)

  fse.writeFileSync(
    pathUtil.getPath(integrationCoverageFile),
    JSON.stringify(newCoverage)
  )
}

let integrationCoverage = null
const integrationCoverageFile = 'integrations/.nyc_output_merge/coverage-final.json'
function _getIntegrationCoverage () {
  if (integrationCoverage) return integrationCoverage
  integrationCoverage = JSON.parse(fse.readFileSync(integrationCoverageFile).toString())
  return integrationCoverage
}

function _updateIntegrationCoverageCache (newCoverage) {
  integrationCoverage = newCoverage
}

function _adjustCoverageStatics ({idx, total}) {
  // adjusting file content
  console.log(chalk.cyan('Starting statementsMap object syncs....'))

  const targetFile = pathUtil.getPath(`integrations/.nyc_output_merge/unit-test-coverage-final-${idx}.json`)
  const integrationCov = _getIntegrationCoverage()
  const obj = JSON.parse(fse.readFileSync(targetFile).toString())
  const newObj = new Map()
  Object.entries(obj).forEach(([key, target]) => {
    const ref = integrationCov[key]
    if (!ref) {
      newObj.set(key, target)
      return
    }

    const targetStatements = Object.values(target.statementMap)
    const refStatements = Object.values(ref.statementMap)

    const targetStats = Object.values(target.s)

    if (targetStatements.length === refStatements.length) {
      newObj.set(key, target)
      return
    }

    const newStats = refStatements.reduce((acc, {start: refStart}) => {
      const index = targetStatements
        .findIndex(({start}) =>
          start.line === refStart.line
        )
      const stat = targetStats[index] || 0

      acc.push(stat)
      return acc
    }, [])

    newObj.set(key, {
      ...target,
      statementMap: refStatements,
      s: newStats
    })
  })

  fse.writeFileSync(targetFile,
    JSON.stringify(Object.fromEntries(newObj), null, 2))
  // adjusting file content
  console.log(chalk.green((idx + 1), '/', total, 'StatementsMap object syncs completed.', targetFile))
}

function _processFile ({filePath, idx, total}) {
  // copy file
  const sourceFile = pathUtil.getPath(filePath)
  const targetFile = pathUtil.getPath(`integrations/.nyc_output_merge/unit-test-coverage-final-${idx}.json`)

  fse.copySync(sourceFile, targetFile)
  console.log(chalk.green('Copied file from unit test to integration tmp folder.'))

  // adjusting integration coverage file
  _adjustIntegrationCoverageDataStructure()

  // adjusting file content
  console.log(chalk.cyan('Starting coverage json file paths adjustment....'))

  const regexStr = '".+\\' + (FILE_SEP === '/' ? '/' : '\\') + '(.+)\\.vue"'
  const vueRegex = new RegExp(regexStr)

  // modify all files with .vue extension with .js
  const lines = fse.readFileSync(targetFile).toString().split('\n')
  for (i in lines) {
    const line = lines[i]
    const match = line.match(vueRegex)
    if (!match) continue

    const name = match[1]
    const newName = name.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z][0-9]|[0-9]+/g)
      .map(x => x.toLowerCase())
      .join('-')
    const fileOrigRegex = new RegExp(name + '\\.vue', 'g')
    lines[i] = line.replace(fileOrigRegex,
      'js' + (FILE_SEP === '/' ? '/' : '\\\\') + newName + '.js')
  }
  const fd = fse.openSync(targetFile, 'w')
  fse.writeFileSync(fd, lines.join('\n'))
  fse.close(fd)

  console.log(chalk.green((idx + 1), '/', total, 'Coverage json file paths adjustment completed.', targetFile))
}
function _sanitizeIntegrationCoverage (filePath) {
  const targetFile = pathUtil.getPath(filePath)
  const obj = JSON.parse(fse.readFileSync(targetFile).toString())

  const newObj = Object.entries(obj).map(([key, info]) => {
    const sanitizedKey = key?.split('?')[0]
    const newInfo = info.data ? info.data : info
    const path = newInfo.path?.split('?')[0]
    const newData = {
      ...newInfo,
      path
    }
    return [sanitizedKey, newData]
  })

  fse.writeFileSync(targetFile,
    JSON.stringify(Object.fromEntries(newObj), null, 2))
  // adjusting file content
  console.log(chalk.green('Coverage file sanitized.', targetFile))
}

function doPostIntegrationTest () {
  const {coverageFinalJsonPath, coverageFinalJsonPaths} = unitTestConfig || {}
  const coveragePaths = [].concat(coverageFinalJsonPath, coverageFinalJsonPaths)
    .filter(i => i)

  _sanitizeIntegrationCoverage(`integrations/.nyc_output_merge/coverage-final.json`)

  if (!coveragePaths.length) {
    console.log(chalk.yellow('Skipping unit-test file copy..'))
    return
  }

  if (!_checkFilesExist(coveragePaths)) {
    return
  }

  const length = coveragePaths.length
  coveragePaths.forEach((filePath, idx) => {
    _processFile({filePath, idx, total: length})
  })

  coveragePaths.forEach((filePath, idx) => {
    _adjustCoverageStatics({idx, total: length})
  })

  coveragePaths.forEach((filePath, idx) => {
    _sanitizeIntegrationCoverage(`integrations/.nyc_output_merge/unit-test-coverage-final-${idx}.json`)
  })
}

module.exports = {
  doPostIntegrationTest
}
