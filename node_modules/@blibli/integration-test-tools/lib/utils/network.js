async function waitForNetworkIdle (page, timeout, maxInflightRequests = 0) {
  page.on('request', onRequestStarted)
  page.on('requestfinished', onRequestFinished)
  page.on('requestfailed', onRequestFinished)

  let inflight = 0
  let fulfill
  const mapRequest = {}
  const MAX_TIMEOUT = 30_000

  const promise = new Promise((resolve, reject) => {
    fulfill = resolve
  })
  let timeoutId = setTimeout(onTimeoutDone, timeout)
  return promise

  function onTimeoutDone () {
    page.removeListener('request', onRequestStarted)
    page.removeListener('requestfinished', onRequestFinished)
    page.removeListener('requestfailed', onRequestFinished)
    fulfill()
  }

  function onRequestStarted (req) {
    mapRequest[req.url()] = 'started'
    ++inflight
    if (inflight > maxInflightRequests) { clearTimeout(timeoutId) }
  }

  function onRequestFinished (req) {
    const failure = req.failure()
    const status = failure ? 'failed' : 'finished'
    mapRequest[req.url()] = status
    
    if (inflight === 0) { return }
    --inflight
    if (inflight === maxInflightRequests) { timeoutId = setTimeout(onTimeoutDone, timeout) }
    
    if (timeout > MAX_TIMEOUT) {
      // print out unfinished request table
      const urls = Object.entries(mapRequest).map(([key, value]) => value === 'started' && key).filter(i => i)
      console.table(urls)

      console.error('Please refer to request status table above and provide proper mocking for each request.')
      
      // terminate spec test to run if network request timeout > 30ms is found
      throw new Error('Network request in the page exceeds 30 seconds, please check the request list provided.')
    }
  }
}

module.exports = {
  waitForNetworkIdle
}
